<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>Farty Unicorn</title>
<style>
  :root{ --bg:#000; --ink:#e6f2ff; --ui:rgba(255,255,255,.92); --pill:#ffffff; }
  *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent }
  html,body{ height:100%; margin:0 }
  body{ background:#000; color:var(--ink); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial }
  /* Vollfl√§chig an Viewport anpassen */
  #wrap{ position:fixed; inset:0; display:grid; place-items:center; }
  canvas{ width:100vw; height:100vh; display:block; background:linear-gradient(#87d6ff,#e9f7ff 60%,#ffffff); box-shadow:0 8px 24px rgba(0,0,0,.35); border-radius:0 }

  /* HUD */
  .hud{ position:fixed; inset:0; pointer-events:none }
  .pill{ background:var(--ui); color:#0b3558; border-radius:999px; padding:8px 12px; font-weight:800; box-shadow:0 2px 8px rgba(0,0,0,.18); }
  .scorePill{ position:fixed; top:12px; right:12px }
  .lives{ position:fixed; top:12px; left:12px; }
  .timePill{ position:fixed; top:12px; left:50%; transform:translateX(-50%); white-space:nowrap; }
  .pauseTag{ position:fixed; inset:0; display:grid; place-items:center; font-weight:900; letter-spacing:.04em; pointer-events:none }
  .pauseTag span{ display:inline-block; padding:.35em .8em; border-radius:1em; background:rgba(0,0,0,.5); color:#fff; font-size:64px }

  /* Settings unten links + Audio unten rechts */
  .topbar{ position:fixed; bottom:10px; left:10px; z-index:5; display:flex; gap:8px; pointer-events:auto }
  .gear,.audioBtn,.btn{ appearance:none; border:none; border-radius:12px; background:#fff; box-shadow:0 2px 8px rgba(0,0,0,.25); padding:8px 10px; font-size:16px; cursor:pointer }
  .audioBtn{ position:fixed; bottom:10px; right:10px }

  /* Panel: einspaltig, scrollf√§hig, max so hoch wie Viewport minus HUD-R√§nder */
  .panel{ position:fixed; bottom:56px; left:10px; right:auto; max-height:calc(100vh - 120px); overflow:auto;
          pointer-events:auto; background:var(--ui); color:#0b3558; border-radius:14px; padding:12px; box-shadow:0 10px 30px rgba(0,0,0,.3); width:min(360px,90vw) }
  .panel.hidden{ display:none }
  .panel h4{ margin:8px 0 6px; font-size:12px; opacity:.8 }
  .row{ display:flex; align-items:center; gap:8px; margin:6px 0; flex-wrap:wrap }
  label{ font-weight:700; font-size:12px }
  select{ appearance:none; padding:6px 10px; border-radius:10px; border:1px solid #cfe5ff; background:#fff; font-weight:700; font-size:12px }
  .pair{ display:flex; align-items:center; justify-content:space-between; gap:8px; width:100% }
  .pair input[type=range]{ width:200px }
  .pair b{ min-width:52px; text-align:right; font-size:11px }
  .help{ position:relative; width:18px; height:18px; display:inline-grid; place-items:center; background:#0b3558; color:#fff;
         border-radius:50%; font-size:12px; cursor:help; margin-left:6px }
  .tip{ position:absolute; z-index:20; inset:auto auto auto 120%; transform:translateY(-30%); width:220px;
        background:#0b3558; color:#e6f2ff; border-radius:10px; padding:10px 12px; font-size:12px; line-height:1.35; box-shadow:0 8px 22px rgba(0,0,0,.35); display:none }
  .help:hover .tip{ display:block }
  .help.edge .tip{ left:auto; right:120%; transform:translateY(-30%) }

  /* Start & Game Over */
  .centerCard{ position:fixed; inset:0; display:grid; place-items:center; z-index:2; pointer-events:none }
  .card{ pointer-events:auto; text-align:center; max-width:min(92vw,720px); background:transparent; color:#0b3558;
         padding: 24px 22px 24px; border-radius:16px; }
  .title{ display:inline-block; font-size:60px; font-weight:900; line-height:1.15; margin:0 0 16px;
          background:linear-gradient(90deg,#ff004c,#ff8a00,#ffe600,#41e66b,#00c2ff,#6a00ff,#ff41f3);
          -webkit-background-clip:text; background-clip:text; color:transparent; background-size:300% 100%; animation:shine 10s linear infinite; }
  @keyframes shine{ 0%{background-position:0 0} 100%{background-position:100% 0} }
  .sub{ margin: 140px 10px 0; opacity:.95; font-size:20px; font-weight:700 } /* 140px Platz f√ºr Farty */
  .sub b{ font-weight:900 }
  .hidden{ display:none }
  .goBig{ position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; font-size:64px; font-weight:900;
          background:transparent; opacity:0; transition:opacity .25s ease; z-index:3 }
  .goBig span{ background:linear-gradient(90deg,#ff004c,#ff8a00,#ffe600,#41e66b,#00c2ff,#6a00ff,#ff41f3);
               -webkit-background-clip:text; background-clip:text; color:transparent; background-size:300% 100%; animation:shine 8s linear infinite }

  .debugTag{ position:fixed; bottom:12px; right:12px; padding:6px 10px; border-radius:10px; background:rgba(0,0,0,.35); color:#41e66b; font-weight:800; font-size:12px; display:none }
  .debugOn .debugTag{ display:block }

  html,body,#wrap,.hud,canvas,.card{ user-select:none; -webkit-user-select:none; }
</style>
</head>
<body>
  <div id="wrap" aria-label="Farty Unicorn game" role="application">
    <canvas id="game" width="360" height="640" aria-hidden="true"></canvas>

    <div class="hud" aria-live="polite">
      <div class="lives pill" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
      <div class="timePill pill" id="timePill">‚è±Ô∏è 00:00.0 ¬∑ Farting 00:00.0 üí®</div>
      <div class="scorePill pill" id="scorePill">Gaps 0 ¬∑ Best 0</div>
      <div class="pauseTag hidden" id="pauseTag"><span>PAUSE</span></div>

      <!-- Settings + Audio -->
      <div class="topbar">
        <button class="gear" id="gearBtn" aria-haspopup="true" aria-expanded="false" title="Settings (S)">‚öôÔ∏è</button>
      </div>
      <button class="audioBtn" id="audioBtn" title="Audio (A)">üîá</button>

      <!-- Panel (einspaltig, alle Slider wieder da) -->
      <div class="panel hidden" id="settingsPanel" role="dialog" aria-label="Settings & Debug">
        <h4>Gameplay</h4>
        <div class="row">
          <label for="controlMode">Steuerung</label>
          <select id="controlMode"><option value="hold" selected>Hold</option><option value="tap">Tap</option></select>
        </div>
        <div class="row">
          <label for="difficulty">Difficulty</label>
          <select id="difficulty">
            <option value="easy" selected>Easy</option>
            <option value="normal">Normal</option>
            <option value="hard">Hard</option>
            <option value="custom">Custom</option>
          </select>
        </div>

        <h4>Fine tuning</h4>
        <!-- Slider + Tooltips -->
        <div class="row pair"><label>Scroll <span class="help">?<span class="tip">Horizontale Weltgeschwindigkeit. H√∂her = schneller. Zu hoch macht das Spiel schwerer.</span></span></label><input id="spSpeed" type="range" min="0.6" max="5.5" step="0.1"><b id="spSpeedVal"></b></div>
        <div class="row pair"><label>Gravity <span class="help">?<span class="tip">Schwerkraft nach unten. H√∂her = st√§rkeres Fallen. Feintuning mit Thrust & Drag.</span></span></label><input id="spG" type="range" min="0.20" max="1.00" step="0.01"><b id="spGVal"></b></div>
        <div class="row pair"><label>Thrust <span class="help">?<span class="tip">Kontinuierlicher Schub beim Halten. St√§rker = mehr Auftrieb. Zu hoch ‚Üí zappelig.</span></span></label><input id="spThrust" type="range" min="-1.60" max="-0.05" step="0.01"><b id="spThrustVal"></b></div>
        <div class="row pair"><label>Flap <span class="help">?<span class="tip">Impuls beim kurzen Tippen/SPACE. Je negativer, desto kr√§ftiger der H√ºpfer.</span></span></label><input id="spFlap" type="range" min="-13" max="-4" step="0.1"><b id="spFlapVal"></b></div>
        <div class="row pair"><label>UpClamp <span class="help">?<span class="tip">Obergrenze f√ºr Aufw√§rtsgeschwindigkeit (negativ). Verhindert zu starke Steigfl√ºge.</span></span></label><input id="spUpClamp" type="range" min="-16" max="-5" step="0.1"><b id="spUpClampVal"></b></div>
        <div class="row pair"><label>MaxFall <span class="help">?<span class="tip">Maximale Fallgeschwindigkeit. H√∂her = schneller nach unten.</span></span></label><input id="spMaxVy" type="range" min="10" max="26" step="0.1"><b id="spMaxVyVal"></b></div>
        <div class="row pair"><label>GapMin <span class="help">?<span class="tip">Kleinste L√ºcke zwischen Wolken. Kleiner = schwerer.</span></span></label><input id="spGapMin" type="range" min="120" max="600" step="5"><b id="spGapMinVal"></b></div>
        <div class="row pair"><label>GapMax <span class="help">?<span class="tip">Gr√∂√üte L√ºcke. Bestimmt die Varianz der Passagen.</span></span></label><input id="spGapMax" type="range" min="180" max="720" step="5"><b id="spGapMaxVal"></b></div>
        <div class="row pair"><label>Spacing <span class="help">?<span class="tip">Abstand zwischen Hindernissen. Kleiner = dichter, schnelleres Reaktionsspiel.</span></span></label><input id="spSpacing" type="range" min="200" max="800" step="10"><b id="spSpacingVal"></b></div>
        <div class="row pair"><label>PipeW <span class="help">?<span class="tip">Wolkenwand-Breite. Breitere W√§nde sind l√§nger im Bild.</span></span></label><input id="spPipeW" type="range" min="40" max="90" step="1"><b id="spPipeWVal"></b></div>
        <div class="row pair"><label>GapPad <span class="help">?<span class="tip">Sicherheitsrand im Gap. H√∂her = gutm√ºtigere Hitbox an Gap-Grenzen.</span></span></label><input id="spGapPad" type="range" min="6" max="36" step="1"><b id="spGapPadVal"></b></div>
        <div class="row pair"><label>HitW <span class="help">?<span class="tip">Hitbox-Breite des Einhorns (sichtbar im Debug-Modus). Kleiner = fairer.</span></span></label><input id="spHitW" type="range" min="14" max="40" step="1"><b id="spHitWVal"></b></div>
        <div class="row pair"><label>HitH <span class="help">?<span class="tip">Hitbox-H√∂he des Einhorns. Kleiner = fairer.</span></span></label><input id="spHitH" type="range" min="8" max="28" step="1"><b id="spHitHVal"></b></div>
        <div class="row pair"><label>Drag <span class="help">?<span class="tip">Luftwiderstand (D√§mpfung). Niedriger = agiler, schnelleres Reagieren.</span></span></label><input id="spDrag" type="range" min="0.960" max="0.998" step="0.001"><b id="spDragVal"></b></div>
        <div class="row pair"><label>Ease <span class="help">?<span class="tip">Gl√§ttung f√ºr Halte-Schub. Niedriger = direkter; h√∂her = weicher.</span></span></label><input id="spEase" type="range" min="0.05" max="0.45" step="0.01"><b id="spEaseVal"></b></div>

        <div class="row" style="justify-content:flex-end; gap:8px;">
          <button class="btn" id="exportBtn" title="Copy settings JSON">‚¨áÔ∏è Export</button>
        </div>
      </div>

      <!-- Start & Game Over Overlay -->
      <div class="centerCard" id="overlay">
        <div class="card" id="startCard">
          <p class="title" id="title">Farty Unicorn</p>
          <p class="sub" id="startSub"></p>
        </div>
      </div>

      <div class="goBig hidden" id="goBig"><span>Game Over</span></div>
      <div class="debugTag" id="debugTag">DEBUG</div>
    </div>
  </div>

  <!-- Audio -->
  <audio id="sndThrust" preload="auto" loop crossorigin="anonymous">
    <source src="https://cdn.pixabay.com/download/audio/2022/08/11/08-10-59-83359.mp3?filename=fart-noises-83359.mp3" type="audio/mpeg">
  </audio>
  <audio id="sndOuch" preload="auto" crossorigin="anonymous">
    <source src="https://cdn.pixabay.com/download/audio/2022/03/15/10-21-20-39978.mp3?filename=ouch-1-39978.mp3" type="audio/mpeg">
  </audio>

<script>
(function(){
'use strict';
/* ========= Boot logging ========= */
const log = (...a)=>console.log('[Farty]', ...a);

/* ========= DOM refs ========= */
const wrap = document.getElementById('wrap');
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const overlay = document.getElementById('overlay');
const startCard = document.getElementById('startCard');
const startSub = document.getElementById('startSub');

const livesEl = document.getElementById('lives');
const timePill = document.getElementById('timePill');
const scorePill = document.getElementById('scorePill');
const pauseTag = document.getElementById('pauseTag');

const gearBtn = document.getElementById('gearBtn');
const audioBtn = document.getElementById('audioBtn');
const panel = document.getElementById('settingsPanel');
const exportBtn = document.getElementById('exportBtn');

const goBig = document.getElementById('goBig');

/* ========= Texts: mobile/desktop ========= */
const isTouch = matchMedia('(pointer:coarse)').matches;
startSub.textContent = isTouch
  ? 'Tap screen repeatedly or hold, take off and fly ...\nPress P for pause, S for Settings and A for Audio.'
  : 'Press SPACE repeatedly or hold, to take off and fly ...\nPress P for pause, S for Settings and A for Audio.';

/* ========= Fit to viewport ========= */
function resizeForDPR(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
  canvas.width = Math.round(cssW*dpr);
  canvas.height = Math.round(cssH*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
function fit(){
  canvas.style.width = '100vw';
  canvas.style.height = '100vh';
  resizeForDPR();
  computeViewTuning();
  positionUnicornForStart(); // parkt Farty zwischen Titel & Sub
}
new ResizeObserver(fit).observe(document.body);
window.addEventListener('resize', fit, {passive:true});
window.addEventListener('orientationchange', fit, {passive:true});

/* ========= Persist ========= */
const LS = {
  get(k,d){ try{ const v=localStorage.getItem(k); return v==null? d:JSON.parse(v); }catch(_){ return d } },
  set(k,v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(_){ } },
  del(k){ try{ localStorage.removeItem(k) }catch(_){ } }
};

/* ========= Presets (agiler) ========= */
const PRESETS = {
  easy:   { G:0.44, FLAP:-6.4, THRUST:-0.70, KICK:-1.8, MAX_VY:16.0, GAP_MIN:260, GAP_MAX:360, SPACING:360, SPEED:2.6, THRUST_EASE:0.22, DRAG:0.979, UP_CLAMP:-9.2 },
  normal: { G:0.52, FLAP:-7.1, THRUST:-0.86, KICK:-2.0, MAX_VY:18.5, GAP_MIN:220, GAP_MAX:310, SPACING:330, SPEED:3.2, THRUST_EASE:0.20, DRAG:0.985, UP_CLAMP:-10.0 },
  hard:   { G:0.60, FLAP:-7.8, THRUST:-1.05, KICK:-2.2, MAX_VY:21.5, GAP_MIN:190, GAP_MAX:270, SPACING:300, SPEED:3.8, THRUST_EASE:0.18, DRAG:0.988, UP_CLAMP:-11.0 },
};

let cfg = PRESETS.easy; // default
let PIPE_W=54, GAP_PAD=18, HIT_W=26, HIT_H=16;

const storedDiff = LS.get('fu_difficulty','easy');
const saved = LS.get('fu_custom', null);
if (storedDiff==='custom' && saved && saved.CFG){
  const vals = Object.values(saved.CFG);
  if (!vals.length || vals.some(v=>!isFinite(v))) {
    log('Corrupt custom settings ‚Üí fallback to easy');
    LS.del('fu_custom'); LS.set('fu_difficulty','easy');
    cfg = PRESETS.easy;
  } else {
    cfg = saved.CFG;
    PIPE_W = saved.PIPE_W ?? PIPE_W;
    GAP_PAD = saved.GAP_PAD ?? GAP_PAD;
    HIT_W = saved.HIT_W ?? HIT_W;
    HIT_H = saved.HIT_H ?? HIT_H;
  }
} else if (PRESETS[storedDiff]) {
  cfg = PRESETS[storedDiff];
}

/* ========= UI selects & sliders ========= */
const $ = (id)=>document.getElementById(id);
const difficultySel = $('difficulty'), modeSel = $('controlMode');

function setDifficulty(val){
  difficultySel.value = val;
  LS.set('fu_difficulty', val);
}
if (difficultySel) difficultySel.value = LS.get('fu_difficulty','easy');
let CONTROL_MODE = LS.get('fu_control','hold'); if (modeSel) modeSel.value = CONTROL_MODE;

function onSlider(id, get, set, fmt){
  const inp=$(id), ro=$(id+'Val'); if(!inp||!ro) return;
  const upd=()=>{ const val=parseFloat(inp.value); set(val); ro.textContent=fmt(val); markCustom(); persistCustom(); };
  inp.addEventListener('input', upd);
  inp.value = get(); ro.textContent = fmt(get());
}
function syncSliders(){
  onSlider('spSpeed',  ()=>cfg.SPEED,      v=>cfg.SPEED=v,      v=>v.toFixed(1));
  onSlider('spG',      ()=>cfg.G,          v=>cfg.G=v,          v=>v.toFixed(2));
  onSlider('spThrust', ()=>cfg.THRUST,     v=>cfg.THRUST=v,     v=>v.toFixed(2));
  onSlider('spFlap',   ()=>cfg.FLAP,       v=>cfg.FLAP=v,       v=>v.toFixed(1));
  onSlider('spUpClamp',()=>cfg.UP_CLAMP,   v=>cfg.UP_CLAMP=v,   v=>v.toFixed(1));
  onSlider('spMaxVy',  ()=>cfg.MAX_VY,     v=>cfg.MAX_VY=v,     v=>v.toFixed(1));
  onSlider('spGapMin', ()=>cfg.GAP_MIN,    v=>cfg.GAP_MIN=v,    v=>v.toFixed(0));
  onSlider('spGapMax', ()=>cfg.GAP_MAX,    v=>cfg.GAP_MAX=v,    v=>v.toFixed(0));
  onSlider('spSpacing',()=>cfg.SPACING,    v=>cfg.SPACING=v,    v=>v.toFixed(0));
  onSlider('spPipeW',  ()=>PIPE_W,         v=>PIPE_W=v,         v=>v.toFixed(0));
  onSlider('spGapPad', ()=>GAP_PAD,        v=>GAP_PAD=v,        v=>v.toFixed(0));
  onSlider('spHitW',   ()=>HIT_W,          v=>HIT_W=v,          v=>v.toFixed(0));
  onSlider('spHitH',   ()=>HIT_H,          v=>HIT_H=v,          v=>v.toFixed(0));
  onSlider('spDrag',   ()=>cfg.DRAG,       v=>cfg.DRAG=v,       v=>v.toFixed(3));
  onSlider('spEase',   ()=>cfg.THRUST_EASE,v=>cfg.THRUST_EASE=v,v=>v.toFixed(2));
}
function persistCustom(){
  if (difficultySel.value!=='custom') return;
  LS.set('fu_custom', { CFG:cfg, PIPE_W, GAP_PAD, HIT_W, HIT_H });
}
function markCustom(){ setDifficulty('custom'); }
if (difficultySel){
  difficultySel.addEventListener('change', ()=>{
    const val=difficultySel.value;
    if (val==='custom'){
      const c=LS.get('fu_custom',null);
      if (c&&c.CFG){ Object.assign(cfg,c.CFG); PIPE_W=c.PIPE_W??PIPE_W; GAP_PAD=c.GAP_PAD??GAP_PAD; HIT_W=c.HIT_W??HIT_W; HIT_H=c.HIT_H??HIT_H; }
    } else {
      Object.assign(cfg, PRESETS[val]||PRESETS.easy);
    }
    syncSliders();
  });
}
if (modeSel){
  modeSel.addEventListener('change', ()=>{ CONTROL_MODE=modeSel.value==='tap'?'tap':'hold'; LS.set('fu_control', CONTROL_MODE); });
}

/* ========= Tooltip Edge-Avoidance ========= */
document.querySelectorAll('.help').forEach(h=>{
  const tip = h.querySelector('.tip');
  h.addEventListener('mouseenter', ()=>{
    const r = tip.getBoundingClientRect();
    if (r.right > innerWidth - 8){ h.classList.add('edge'); } else { h.classList.remove('edge'); }
  });
});

/* ========= Export Settings ========= */
$('exportBtn').addEventListener('click', ()=>{
  const payload = { difficulty: difficultySel.value, CFG:cfg, PIPE_W, GAP_PAD, HIT_W, HIT_H };
  const txt = JSON.stringify(payload, null, 2);
  navigator.clipboard.writeText(txt).then(()=> showToast('Settings copied to clipboard!'));
});
function showToast(msg){
  const t=document.createElement('div');
  t.textContent=msg;
  Object.assign(t.style,{position:'fixed',bottom:'64px',left:'50%',transform:'translateX(-50%)',
    background:'#0b3558',color:'#e6f2ff',padding:'10px 14px',borderRadius:'12px',boxShadow:'0 6px 16px rgba(0,0,0,.35)',zIndex:9999,opacity:'0',transition:'opacity .2s, transform .2s'});
  document.body.appendChild(t); requestAnimationFrame(()=>{ t.style.opacity='1'; t.style.transform='translateX(-50%) translateY(-6px)'; });
  setTimeout(()=>{ t.style.opacity='0'; t.style.transform='translateX(-50%) translateY(0)'; setTimeout(()=>t.remove(),220); }, 1200);
}

/* ========= View tuning ========= */
let VIEW = { SPEED:1, THRUST:1, GRAV:1, SPACING:1, GAP_ADD:0, PIPE_W:1, landscape:false };
function computeViewTuning(){
  const vw = innerWidth, vh = innerHeight;
  const land = vw >= vh; VIEW.landscape = land;
  if (land){ VIEW.SPEED=1.15; VIEW.THRUST=1.00; VIEW.GRAV=1.00; VIEW.SPACING=1.05; VIEW.GAP_ADD=20; VIEW.PIPE_W=1.02; }
  else { VIEW.SPEED=1.00; VIEW.THRUST=1.00; VIEW.GRAV=1.00; VIEW.SPACING=1.00; VIEW.GAP_ADD=0; VIEW.PIPE_W=1.00; }
}
const W = ()=>canvas.clientWidth, H = ()=>canvas.clientHeight;

/* ========= State ========= */
let unicorn, pipes, particles, rings, score=0, best=Number(LS.get('fu_best','0'))||0;
let started=false, running=false, paused=false;
let lives=3, invuln=0;
let thrusting=false, thrustAcc=0;
let spaceDown=false, pointerDown=false;

/* Runtime/Fart-Time nur ingame */
let runAccum=0, lastTick=null;     // ms
let fartAccum=0, fartStart=null;   // ms

/* ========= Audio ========= */
let audioOn = false;
const elThrust = document.getElementById('sndThrust');
const elOuch   = document.getElementById('sndOuch');
elThrust.volume = 0.25;
elOuch.volume = 0.35;
function toggleAudio(on){
  audioOn = (on==null)? !audioOn : !!on;
  audioBtn.textContent = audioOn ? 'üîä' : 'üîá';
  if (!audioOn){ elThrust.pause(); elThrust.currentTime = 0; }
}
audioBtn.addEventListener('click', ()=>toggleAudio());
window.addEventListener('keydown', (e)=>{ if (e.key==='a'||e.key==='A'){ toggleAudio(); }});

/* ========= Panel/Pause ========= */
function setPaused(p){
  const want = !!p;
  if (paused===want) return;
  paused = want;
  pauseTag.classList.toggle('hidden', !paused);
  if (paused){ elThrust.pause(); } else if (thrusting && audioOn){ elThrust.play().catch(()=>{}); }
}
function togglePanel(open){
  const show = (open==null)? panel.classList.contains('hidden') : !!open;
  if (show){
    panel.classList.remove('hidden'); gearBtn.setAttribute('aria-expanded','true');
    setPaused(true); // immer pausieren beim √ñffnen
    setTimeout(()=>panel.scrollTop=0,0);
  } else {
    panel.classList.add('hidden'); gearBtn.setAttribute('aria-expanded','false');
    /* Wichtig: NICHT automatisch entpausieren */
  }
}
gearBtn.addEventListener('click', ()=>togglePanel());
window.addEventListener('keydown', (e)=>{
  if (e.key==='s'||e.key==='S'){ e.preventDefault(); togglePanel(); }
  if (e.key==='p'||e.key==='P'){ if (started) setPaused(!paused); }
});

/* ========= Particles / FX ========= */
const PARTICLE_BUDGET = 1100;
particles=[]; rings=[];
function fartHue(i,t){ return (t*4 + i*15) % 360; }
function fartBurst(n=24){
  for(let i=0;i<n;i++){
    const hue=fartHue(i, unicorn.t);
    particles.push({ x:unicorn.x-10, y:unicorn.y+4, vx:-3.0 - Math.random()*2.2, vy:(Math.random()*2-1)*1.0, life:70+Math.random()*30, hue, r:3+Math.random()*2.8, type:'jet' });
  }
  for(let i=0;i<8;i++){
    const hue=(unicorn.t*3 + i*45)%360;
    particles.push({ x:unicorn.x-12, y:unicorn.y+6, vx:-2.0 - Math.random()*1.2, vy:(Math.random()*2-1)*0.6, life:90+Math.random()*20, hue, r:4.5+Math.random()*2.5, type:'plume' });
  }
}
function sparkBurst(){
  for (let i=0;i<18;i++){
    const a=Math.random()*Math.PI*2; const sp=1.6+Math.random()*1.8; const hue=(unicorn.t*5 + i*18)%360;
    particles.push({ x:unicorn.x-6, y:unicorn.y+4, vx:Math.cos(a)*sp-2, vy:Math.sin(a)*sp*0.6, life:28+Math.random()*18, hue, r:1.8+Math.random()*1.4, type:'spark' });
  }
}
function shockwave(){ rings.push({ x:unicorn.x-8, y:unicorn.y+4, r:6, w:3.5, life:24 }); }
function fartStream(){
  for (let i=0;i<4;i++){
    const hue=(unicorn.t*3 + i*22)%360;
    particles.push({ x:unicorn.x-10, y:unicorn.y+4, vx:-2.6 - Math.random()*1.6, vy:(Math.random()*2-1)*0.6, life:62+Math.random()*22, hue, r:2.6+Math.random()*1.6, type:'jet' });
  }
}
function updateParticles(){
  for (let i=particles.length-1;i>=0;i--){
    const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.032; p.life-=1; if (p.life<=0) particles.splice(i,1);
  }
  if (running && !paused && thrusting && CONTROL_MODE==='hold') fartStream();
  if (particles.length>PARTICLE_BUDGET) particles.splice(0, particles.length-PARTICLE_BUDGET);
}
function drawParticles(){
  ctx.save(); ctx.globalCompositeOperation='source-over';
  for (const p of particles){
    const a=Math.max(0, p.life/(p.type==='spark'?40:90));
    const col=`hsl(${p.hue},95%,60%)`; ctx.globalAlpha=a; ctx.shadowBlur=8; ctx.shadowColor=col; ctx.fillStyle=col;
    ctx.beginPath(); if (p.type==='jet'){ ctx.ellipse(p.x,p.y,p.r*1.4,p.r*0.9,0,0,Math.PI*2); } else { ctx.arc(p.x,p.y,p.r,0,Math.PI*2); } ctx.fill();
  }
  ctx.restore(); ctx.globalAlpha=1;
}
function updateRings(){ for (let i=rings.length-1;i>=0;i++){ const r=rings[i]; r.r+=2.4; r.w*=0.96; r.life--; if (r.life<=0) rings.splice(i,1); } }
function drawRings(){ ctx.save(); ctx.globalAlpha=0.5; ctx.strokeStyle='rgba(255,255,255,.85)'; for (const r of rings){ ctx.lineWidth=Math.max(0.8,r.w); ctx.beginPath(); ctx.arc(r.x,r.y,Math.max(1,r.r),0,Math.PI*2); ctx.stroke(); } ctx.restore(); }

/* ========= Drawing helpers ========= */
function circle(x,y,r, fill){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=fill; ctx.fill(); }
function triangle(x1,y1,x2,y2,x3,y3, fill){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.lineTo(x3,y3); ctx.closePath(); ctx.fillStyle=fill; ctx.fill(); }
function roundedRect(x,y,w,h,r, fill){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fillStyle=fill; ctx.fill(); }

/* ========= Clouds & Obstacles ========= */
function drawCloud(x,y,w,h){ ctx.fillStyle='#fff'; const rr=Math.min(w,h)/4;
  circle(x+w*0.2,y+h*0.6,rr,'#fff'); circle(x+w*0.4,y+h*0.5,rr*1.1,'#fff'); circle(x+w*0.6,y+h*0.55,rr*0.95,'#fff'); circle(x+w*0.75,y+h*0.65,rr*0.85,'#fff'); ctx.fillRect(x+w*0.1,y+h*0.6,w*0.8,h*0.4);
}
function drawObstacle(p){
  // Top
  ctx.save(); ctx.beginPath(); ctx.rect(p.x,0,p.w,p.top); ctx.clip(); ctx.fillStyle='#fff'; ctx.fillRect(p.x,0,p.w,p.top);
  for(let i=0;i<3;i++){ drawCloud(p.x-6+i*(p.w/3), p.top*0.45-20, p.w*0.9, p.top*0.6); }
  ctx.restore();
  // Bottom
  const by=p.top+p.gap, bh=H()-by; ctx.save(); ctx.beginPath(); ctx.rect(p.x,by,p.w,bh); ctx.clip(); ctx.fillStyle='#fff'; ctx.fillRect(p.x,by,p.w,bh);
  for(let i=0;i<3;i++){ drawCloud(p.x-6+i*(p.w/3), by+bh*0.0, p.w*0.9, bh*0.6+24); }
  ctx.restore();

  // Debug Linien (Gap-R√§nder)
  if (DEBUG_ON){
    ctx.save(); ctx.strokeStyle='rgba(0,128,0,.6)'; ctx.setLineDash([4,6]);
    ctx.beginPath(); ctx.moveTo(p.x, p.top+GAP_PAD); ctx.lineTo(p.x+p.w, p.top+GAP_PAD); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(p.x, p.top+p.gap-GAP_PAD); ctx.lineTo(p.x+p.w, p.top+p.gap-GAP_PAD); ctx.stroke();
    ctx.restore();
  }
}

/* ========= Unicorn ========= */
let DEBUG_ON = false;
function drawRainbowWing(x,y,t){ const hues=[0,25,50,120,200,260,300];
  for(let i=0;i<hues.length;i++){ const offY=Math.sin(t/8 + i*0.6)*2 - i*2.4; const w=22 - i*2.2; const h=7; const r=3.5;
    roundedRect(x - 4 - i*5, y + offY, w, h, r, `hsl(${hues[i]}, 90%, 65%)`);
  }
}
function drawUnicorn(u){ const x=u.x,y=u.y,t=u.t; const wingOff=Math.sin(t/6)*4;
  drawRainbowWing(x-2, y-18+wingOff, t);
  roundedRect(x-22,y-15,44,30,14,'#fff'); // body
  // mane
  for(let i=0;i<5;i++){ ctx.fillStyle=`hsl(${(i*50+280)%360}, 90%, 65%)`; roundedRect(x-25,y-14+i*5,14,3.5,1.7,ctx.fillStyle); }
  // cheek/eye/ear/horn/feet
  circle(x+5,y+6,3.2,'#ffd0e6'); circle(x+11,y-2.5,2.8,'#2b2b2b');
  triangle(x+8,y-20,x+14,y-8,x+4,y-10,'#fff'); triangle(x+8,y-18,x+12,y-10,x+6,y-11,'#ffd0e6');
  // horn 45¬∞
  ctx.save(); ctx.translate(x+22,y-8); ctx.rotate(-Math.PI/4); triangle(0,-4, 0,4, 12,0, '#ffd166'); ctx.restore();
  // feet & dangling legs
  circle(x-12,y+15,2.3,'#444'); circle(x+5,y+15,2.3,'#444');
  const leg = Math.sin(t/7)*2; circle(x-13,y+16+leg,2,'#444'); circle(x+6,y+16-leg,2,'#444');
  if (DEBUG_ON){ const hbw=HIT_W/2,hbh=HIT_H/2; ctx.save(); ctx.strokeStyle='rgba(0,200,0,.7)'; ctx.setLineDash([5,3]); ctx.strokeRect(x-hbw,y-hbh,HIT_W,HIT_H); ctx.restore(); }
}

/* ========= Obstacles ======== */
function gapWithView(){ const min=Math.max(120, cfg.GAP_MIN + VIEW.GAP_ADD); const max=Math.max(min+20, cfg.GAP_MAX + VIEW.GAP_ADD); return {min,max}; }
function randGap(){ const g=gapWithView(); return g.min + Math.random()*(g.max-g.min); }
function addPipe(x){
  const gap=randGap(); const maxTop=Math.max(60, H()-gap-100);
  const topH=50+Math.random()*maxTop; const w=Math.round(PIPE_W*VIEW.PIPE_W);
  pipes.push({ x, w, top:topH, gap, scored:false });
}
function tryAddPipes(){
  const rightMost=pipes.length? Math.max(...pipes.map(p=>p.x)) : 0;
  const spacing=Math.round(cfg.SPACING*VIEW.SPACING);
  if (rightMost < W()+20) addPipe((pipes.length? rightMost: W()) + spacing);
}

/* ========= Runtime/Score UI ========= */
function fmtTime(ms){ const t=Math.max(0, Math.floor(ms)); const s=Math.floor(t/1000), m=Math.floor(s/60); const ds=Math.floor((t%1000)/100);
  return `${String(m).padStart(2,'0')}:${String(s%60).padStart(2,'0')}.${ds}`;
}
function updateHUD(){
  const run = fmtTime(runAccum);
  const fart = fmtTime(fartAccum + (thrusting && !paused && running && CONTROL_MODE==='hold' && fartStart? (performance.now()-fartStart):0));
  timePill.textContent = `‚è±Ô∏è ${run} ¬∑ Farting ${fart} üí®`;
  livesEl.textContent = '‚ù§Ô∏è'.repeat(lives) + 'ü§ç'.repeat(3-lives);
  scorePill.textContent = `Gaps ${score} ¬∑ Best ${best}`;
}

/* ========= Lifecycle ========= */
function reset(){
  unicorn={ x:W()*0.28, y:H()*0.45, vy:0, r:18, t:0 };
  pipes=[]; particles=[]; rings=[]; score=0; thrustAcc=0; lives=3; invuln=0;
  const spacing = Math.round(cfg.SPACING*VIEW.SPACING);
  addPipe(W()+120); addPipe(W()+120+spacing);
  // Runtime/Fart-Time zur√ºcksetzen
  runAccum=0; lastTick=null; fartAccum=0; fartStart=null;
  updateHUD();
}
function gameOver(){
  running=false;
  // GO-Animation (Zoom in + weiter furzen)
  const startX=unicorn.x, startY=unicorn.y;
  const targetX=W()*0.5, targetY=H()*0.5;
  const dur=900; const t0=performance.now();
  // ‚ÄûGame Over‚Äú-Text zun√§chst ausblenden
  goBig.classList.add('hidden'); goBig.style.opacity='0';
  function anim(){
    const t=performance.now()-t0; const k=Math.min(1, t/dur);
    const e = k<0.5 ? 2*k*k : 1 - Math.pow(-2*k+2,2)/2;
    unicorn.x = startX + (targetX-startX)*e;
    unicorn.y = startY + (targetY-startY)*e;
    unicorn.r = 18*(1+e*4.2);
    thrusting=true; fartStream(); sparkBurst();
    if (k<1){ requestAnimationFrame(anim); }
    else{
      thrusting=false;
      goBig.classList.remove('hidden'); goBig.style.opacity='1';
      setTimeout(()=>{
        goBig.style.opacity='0';
        setTimeout(()=>{
          goBig.classList.add('hidden');
          started=false; paused=false;
          overlay.classList.remove('hidden'); // Startscreen zur√ºck
          positionUnicornForStart();
          lives=3; updateHUD();
        }, 250);
      }, 850);
    }
  }
  anim();
  best=Math.max(best,score); LS.set('fu_best', best);
}
function start(boostKind){
  started=true; running=true; setPaused(false);
  overlay.classList.add('hidden');
  if (document.activeElement===gearBtn) gearBtn.blur();
  reset();
  // sofortiger Schub beim ersten Input
  if (boostKind==='tap'){ flap(); }
  else if (boostKind==='hold'){ startThrust(); thrusting=true; fartStart=performance.now(); setTimeout(()=>{ if (!spaceDown && !pointerDown) endThrust(); }, 120); }
  log('Game started');
}

/* ========= Input ========= */
function flap(){
  unicorn.vy=Math.max(cfg.UP_CLAMP, unicorn.vy + cfg.FLAP);
  fartBurst(22); sparkBurst(); shockwave();
  // kurzer ‚ÄûFart‚Äú-Ton
  if (audioOn){ try{ elThrust.currentTime=0; elThrust.play().catch(()=>{}); }catch(_){ } }
  // Fart-Time Impuls
  if (!thrusting){ thrusting=true; fartStart=performance.now(); setTimeout(()=>{ if (thrusting){ endThrust(); } }, 90); }
}
function startThrust(){
  if (unicorn.vy > cfg.UP_CLAMP*0.6) unicorn.vy += cfg.KICK;
  if (audioOn){ try{ elThrust.play().catch(()=>{}); }catch(_){} }
  if (!thrusting){ thrusting=true; fartStart=performance.now(); }
}
function endThrust(){
  if (thrusting){
    thrusting=false;
    if (audioOn){ elThrust.pause(); }
    if (fartStart!=null){ fartAccum += Math.max(0, performance.now()-fartStart); fartStart=null; }
  }
}
function startAndBoost(kind){
  if (!started || !running){ start(kind==='tap'?'tap':'hold'); return; }
  if (paused){ setPaused(false); return; }
}

/* Maus/Touch */
canvas.addEventListener('pointerdown', (e)=>{
  if (!started||!running||paused){ startAndBoost(e.pointerType==='mouse'?'hold':'tap'); }
  if (CONTROL_MODE==='tap') flap(); else { pointerDown=true; startThrust(); }
});
canvas.addEventListener('pointerup',   ()=>{ pointerDown=false; endThrust(); });
canvas.addEventListener('pointerleave',()=>{ pointerDown=false; endThrust(); });
/* Zwei-Finger-Pause */
document.addEventListener('touchstart', (e)=>{ if (e.touches && e.touches.length===2){ setPaused(!paused); } }, {passive:true});

/* Globaler Start bei erstem Klick/Key au√üerhalb Panel */
function notInUI(t){ return !(t.closest && (t.closest('#settingsPanel')||t.closest('#gearBtn')||t.closest('#audioBtn'))); }
document.body.addEventListener('pointerdown', (e)=>{ if (!started||!running||paused){ if (notInUI(e.target)) startAndBoost('tap'); } }, true);

/* Keyboard */
window.addEventListener('keydown', (e)=>{
  const isSpace = (e.code==='Space' || e.key===' ' || e.key==='Spacebar');
  if (isSpace){
    e.preventDefault();
    if (!started||!running||paused){ startAndBoost('hold'); }
    if (CONTROL_MODE==='tap') flap(); else { spaceDown=true; startThrust(); }
  }
  if (e.key==='Enter'){ e.preventDefault(); startAndBoost('tap'); }
});
window.addEventListener('keyup', (e)=>{ const isSpace=(e.code==='Space'||e.key===' '||e.key==='Spacebar'); if (isSpace){ spaceDown=false; endThrust(); }});

/* ========= Collision / Physics ========= */
function bounceCrashFX(){
  // roter Overlay-Blob, gr√∂√üer und fade
  const fx = { x:unicorn.x, y:unicorn.y, r:14, a:0.55, life:22 };
  (function anim(){
    fx.r *= 1.5; fx.a *= 0.88; fx.life--;
    ctx.save(); ctx.globalAlpha = Math.max(0, fx.a); ctx.fillStyle='red'; circle(fx.x,fx.y,fx.r,'red'); ctx.restore();
    if (fx.life>0) requestAnimationFrame(anim);
  })();
}
function collideWithPipe(p){
  const hbw=HIT_W/2, hbh=HIT_H/2;
  const overlapsX=(unicorn.x+hbw>p.x)&&(unicorn.x-hbw<p.x+p.w);
  if (!overlapsX) return false;
  const safeTop=p.top+GAP_PAD, safeBottom=p.top+p.gap-GAP_PAD;
  if ((unicorn.y-hbh)>=safeTop && (unicorn.y+hbh)<=safeBottom){ return false; } // im Gap ‚Üí ok
  // Crash
  if (invuln>0) return true; // schon gez√§hlt, trotzdem abprallen
  lives = Math.max(0, lives-1);
  if (audioOn){ try{ elOuch.currentTime=0; elOuch.play().catch(()=>{}); }catch(_){} }
  invuln = 1000; // 1s Unverwundbarkeit
  // R√ºcksto√ü
  const dir = (unicorn.y < safeTop)? -1 : +1;
  unicorn.vy = Math.min( -cfg.KICK*3, dir<0? -8: +8 );
  unicorn.x -= 12;
  bounceCrashFX();
  return true;
}

/* ========= Scene Drawing ========= */
function drawCloudBand(){
  const grd=ctx.createLinearGradient(0,0,0,H()); grd.addColorStop(0,'#bde6ff'); grd.addColorStop(1,'#ffffff'); ctx.fillStyle=grd; ctx.fillRect(0,0,W(),H());
}
function drawSceneIdle(){
  unicorn.t++;
  positionUnicornForStart();
  for(const p of pipes) drawObstacle(p);
  updateParticles(); drawParticles(); updateRings(); drawUnicorn(unicorn);
}
function positionUnicornForStart(){
  if (!startCard) return;
  const card = startCard.getBoundingClientRect();
  const frame = wrap.getBoundingClientRect();
  const cx = frame.left + frame.width/2;
  const slotY = card.top + 92; // Slot zwischen Title & Sub (angepasst auf neue Sub-Margin)
  unicorn = unicorn || {x:0,y:0,vy:0,t:0,r:18};
  unicorn.x = cx - frame.left;
  unicorn.y = slotY - frame.top;
}

/* ========= Main Loop ========= */
let raf;
function loop(){
  raf = requestAnimationFrame(loop);
  drawCloudBand();

  // Runtime-Accu nur, wenn spielend & nicht pausiert
  const now = performance.now();
  if (running && !paused){
    if (lastTick==null) lastTick = now;
    runAccum += (now - lastTick);
  }
  lastTick = now;

  if (!started){ if (!unicorn) reset(); drawSceneIdle(); updateHUD(); return; }
  if (paused){ for(const p of pipes) drawObstacle(p); drawParticles(); drawRings(); drawUnicorn(unicorn); return; }

  unicorn.t++;

  // Hold thrust
  if (CONTROL_MODE==='hold'){
    const want = (spaceDown || pointerDown);
    if (want && !thrusting){ startThrust(); }
    if (!want && thrusting){ endThrust(); }
    thrusting = want;
  }

  const target=(CONTROL_MODE==='hold' && thrusting)? cfg.THRUST*VIEW.THRUST:0;
  thrustAcc += (target - thrustAcc)*cfg.THRUST_EASE;
  unicorn.vy += (cfg.G*VIEW.GRAV) + thrustAcc;
  unicorn.vy *= cfg.DRAG;
  if (unicorn.vy < cfg.UP_CLAMP) unicorn.vy = cfg.UP_CLAMP;
  if (unicorn.vy > cfg.MAX_VY) unicorn.vy = cfg.MAX_VY;
  unicorn.y += unicorn.vy;
  if (unicorn.y < 10){ unicorn.y=10; unicorn.vy=0; }
  if (unicorn.y > H()-22){ unicorn.y=H()-22; lives=0; updateHUD(); gameOver(); return; }

  for (const p of pipes) p.x -= cfg.SPEED * VIEW.SPEED;
  if (pipes.length && pipes[0].x + pipes[0].w < -10) pipes.shift();
  tryAddPipes();

  for (const p of pipes){
    drawObstacle(p);
    // Scoring
    const hbw=HIT_W/2;
    if (!p.scored && p.x+p.w < unicorn.x - hbw){ p.scored=true; score++; }
    // Collision
    const hit = collideWithPipe(p);
    if (hit && lives===0){ updateHUD(); gameOver(); return; }
  }

  updateParticles(); drawParticles(); updateRings(); drawUnicorn(unicorn);
  updateHUD();
}

/* ========= Boot ========= */
function init(){
  computeViewTuning(); fit(); reset(); syncSliders(); loop();
  toggleAudio(false);
  log('Boot complete');
}
init();

/* ========= Settings: √ñffnen via S pausiert, Schlie√üen bel√§sst Pause ========= */
document.addEventListener('pointerdown',(e)=>{
  const inside = e.target.closest && e.target.closest('#settingsPanel');
  if (panel && !panel.classList.contains('hidden') && !inside && e.target!==gearBtn){
    panel.classList.add('hidden'); gearBtn.setAttribute('aria-expanded','false'); /* bleibt pausiert */
  }
});

/* ========= Public simple tests ========= */
window.FU = {
  runTests(){
    const results=[];
    const assert=(name,cond)=>results.push((cond?'‚úÖ':'‚ùå')+' '+name);
    // Startscreen zeigt Zeit 00:00.0
    assert('runtime gated at start', timePill.textContent.includes('00:00.0'));
    // Settings √∂ffnen pausiert
    togglePanel(true); assert('panel opens', !panel.classList.contains('hidden')); assert('paused on open', paused===true);
    // Schlie√üen bel√§sst Pause
    togglePanel(false); assert('panel closes', panel.classList.contains('hidden')); assert('still paused', paused===true);
    // Start l√∂st aus & schiebt Schub
    setPaused(false); start('tap'); assert('started', started&&running); assert('overlay hidden', overlay.classList.contains('hidden'));
    console.log('[Farty TESTS]', '\n'+results.join('\n'));
  }
};
})();
</script>
</body>
</html>
